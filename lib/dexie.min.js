/*
 * Simplified IndexedDB wrapper for Personal Finance Tracker
 * This provides a Dexie-like API using native IndexedDB
 */

window.Dexie = class Dexie {
    constructor(name) {
        this.name = name;
        this._stores = {};
        this._version = 1;
        this.db = null;
    }

    version(versionNumber) {
        this._version = versionNumber;
        return {
            stores: (storeSchema) => {
                this._stores = storeSchema;
                return this;
            }
        };
    }

    async open() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.name, this._version);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Create object stores based on schema
                for (const [storeName, schema] of Object.entries(this._stores)) {
                    if (!db.objectStoreNames.contains(storeName)) {
                        const store = db.createObjectStore(storeName, { keyPath: 'id' });
                        
                        // Create indexes based on schema
                        if (schema.includes('date')) store.createIndex('date', 'date');
                        if (schema.includes('categoryId')) store.createIndex('categoryId', 'categoryId');
                        if (schema.includes('type')) store.createIndex('type', 'type');
                        if (schema.includes('amount')) store.createIndex('amount', 'amount');
                        if (schema.includes('name')) store.createIndex('name', 'name');
                    }
                }
            };
        });
    }

    table(name) {
        return {
            add: async (data) => {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([name], 'readwrite');
                    const store = transaction.objectStore(name);
                    const request = store.add(data);
                    
                    request.onsuccess = () => resolve(data.id);
                    request.onerror = () => reject(request.error);
                });
            },
            
            put: async (data) => {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([name], 'readwrite');
                    const store = transaction.objectStore(name);
                    const request = store.put(data);
                    
                    request.onsuccess = () => resolve(data.id);
                    request.onerror = () => reject(request.error);
                });
            },
            
            get: async (id) => {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([name], 'readonly');
                    const store = transaction.objectStore(name);
                    const request = store.get(id);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            
            toArray: async () => {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([name], 'readonly');
                    const store = transaction.objectStore(name);
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            },
            
            where: (field) => ({
                equals: (value) => ({
                    toArray: async () => {
                        return new Promise((resolve, reject) => {
                            const transaction = this.db.transaction([name], 'readonly');
                            const store = transaction.objectStore(name);
                            const index = store.index(field);
                            const request = index.getAll(value);
                            
                            request.onsuccess = () => resolve(request.result || []);
                            request.onerror = () => reject(request.error);
                        });
                    }
                }),
                between: (min, max) => ({
                    toArray: async () => {
                        return new Promise((resolve, reject) => {
                            const transaction = this.db.transaction([name], 'readonly');
                            const store = transaction.objectStore(name);
                            const index = store.index(field);
                            const range = IDBKeyRange.bound(min, max);
                            const request = index.getAll(range);
                            
                            request.onsuccess = () => resolve(request.result || []);
                            request.onerror = () => reject(request.error);
                        });
                    }
                })
            }),
            
            delete: async (id) => {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([name], 'readwrite');
                    const store = transaction.objectStore(name);
                    const request = store.delete(id);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            
            clear: async () => {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([name], 'readwrite');
                    const store = transaction.objectStore(name);
                    const request = store.clear();
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        };
    }
};